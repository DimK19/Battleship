package backend;

import java.util.ArrayList;
import java.util.Stack;

/**
 * This is the class that defines fields and methods for both types of players.
 * 
 * @author Dimitrios Kyriakidis
 *
 */

public abstract class Player
{
    private int movesPlayed, points;
    private ArrayList<Ship> ships;
    Stack<CustomPair> allMovesStack;
    private boolean[][] hitArray;
    
    /**
     * 
     */
    public Player()
    {
        this.movesPlayed = 0;
        this.points = 0;
        allMovesStack = new Stack<CustomPair>();
        
        hitArray = new boolean[20][20];
        /*
        for(int i = 0; i < 10; ++i)
            for(int j = 0; j < 10; ++j) hitArray[i][j] = false;
        */
        ships = new ArrayList<Ship>();
        ships.add(new Carrier());
        ships.add(new Battleship());
        ships.add(new Cruiser());
        ships.add(new Submarine());
        ships.add(new Destroyer());
    }
    
    /**
     * @return How many moves have been played by this player (<code>int</code>).
     */
    public int getMovesPlayed()
    {
        return this.movesPlayed;
    }
    
    /**
     * @return An <code>ArrayList</code> of <code>Ship</code> objects, the ships controlled by the player.
     */
    public ArrayList<Ship> getShips()
    {
        return ships;
    }
    
    /**
     * @return How many of the player's ships have not been sunken.
     */
    public int getActiveShips()
    {
        int counter = 0;
        for(Ship s : this.ships) if(!s.getState().equals("sunken")) counter++;
        return counter;
    }
    
    /**
     * @return The sum of this player's points.
     */
    public int getTotalPoints()
    {
        return points;
    }
    
    /**
     * @param n The amount of points to be added to the total.
     */
    public void addPoints(int n)
    {
        points += n;
    }
    
    /**
     * @return The ratio of successful hits to the total number of hits (<code>double</code>, between 0 and 1).
     */
    public double getSuccessRate()
    {
        if(allMovesStack.isEmpty()) return 0;
        int sum = 0;
        
        for(CustomPair m : allMovesStack)
            if(m.getRight() != 0) sum++;
        
        return (double)sum / (double)allMovesStack.size();
    }
    
    
    public void incrementMoveCounter()
    {
        this.movesPlayed++;
    }

    /**
     * After a successful shot is fired by the opponent, updates the corresponding ship's hit-points. 
     * @param type The type (subclass) of <code>Ship</code> that was hit.
     * @see Ship
     */
    public void updateShips(int type)
    {
        if(type <= 0) return;
        else ships.get(--type).hit();
    }
    
    /**
     * @return A <code>Stack</code> (from <code>java.util.Stack</code>) of 
     *         <code>CustomPair</code> objects, the coordinates of every move the player 
     *         has made, paired with the corresponding outcome.
     * 
     * @see Coordinate
     * @see CustomPair 
     */
    public Stack<CustomPair> getAllMovesStack()
    {
        return allMovesStack;
    }

    /**
     * Adds a pair of move coordinates and shot outcome to the player's stack of all moves.
     * 
     * @param c The <code>Coordinate</code>.
     * @param outcome Hit outcome (<code>int</code>), generated by the function
     *                <code>Board.getHitOutcome</code>.
     *                
     * @see Coordinate
     * @see Board
     */
    public void pushToMoves(Coordinate c, int outcome)
    {
        this.allMovesStack.push(new CustomPair(c, outcome));
        hitArray[c.getX()][c.getY()] = true;
        if(outcome > 0) this.addPoints(ships.get(outcome - 1).getPoints());
    }
    
    /**
     * Also overloaded for <code>int</code> parameters.
     * 
     * @param c The coordinates, in the form of a <code>Coordinate</code> object.
     * @return <code>True</code> if a shot has already been fired at specified coordinates, 
     *         <code>False</code> otherwise.
     * 
     * @see Coordinate
     */
    public boolean hasBeenShot(Coordinate c)
    {
        return hitArray[c.getX()][c.getY()];
    }
    
    /**
     * Also overloaded for <code>Coordinate</code> parameter.
     * 
     * @param x Horizontal axis coordinate.
     * @param y Vertical axis coordinate.
     * @return <code>True</code> if a shot has already been fired at specified coordinates, 
     *         <code>False</code> otherwise.
     *         
     * @see Coordinate
     */
    public boolean hasBeenShot(int x, int y)
    {
        return hitArray[x][y];
    }
    
    /**
     * @return A <code>String</code> containing the names and conditions of all of the player's ships,
     *         one per line.
     */
    public String getShipReport()
    {
        String r = "";
        
        for(Ship s : this.ships)
        {
            String temp = s.getName() + ": " + s.getState() + '\n';
            r += temp;
        }
        
        return r;
    }
    
    /**
     * @return A <code>String</code> containing the coordinates of all of the player's shots,
     *         and what their outcome was ("Name of ship" or "Water").
     */
    public String getShotReport()
    {
        String r = "";
        
        for(int i = allMovesStack.size() - 1; i >= Math.max(allMovesStack.size() - 5, 0); --i)
        {
            CustomPair cm = allMovesStack.get(i);
            System.out.println(cm.getLeft().toString() + ' ' + Board.entities[cm.getRight()]);
            r += cm.getLeft().toString() + ": " + Board.entities[cm.getRight()] + '\n';
        }

        return r;
    }
    
    /**
     * Abstract method that returns the player's next move
     * 
     * @return Coordinates to be fired at, as a Coordinate object.
     * 
     * @see HumanPlayer
     * @see ComputerPlayer
     */
    public abstract Coordinate makeMove();

}
